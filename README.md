# PSPPool [![Build Status](https://travis-ci.org/ViktorC/PSPPool.svg?branch=master)](https://travis-ci.org/ViktorC/PSPPool) [![Quality Gate](https://sonarqube.com/api/badges/gate?key=net.viktorc:pspp)](https://sonarqube.com/dashboard/index/net.viktorc:pspp) [![Quality Gate](https://sonarqube.com/api/badges/measure?key=net.viktorc:pspp&metric=coverage)](https://sonarqube.com/dashboard/index/net.viktorc:pspp) [![Quality Gate](https://sonarqube.com/api/badges/measure?key=net.viktorc:pspp&metric=ncloc)](https://sonarqube.com/dashboard/index/net.viktorc:pspp)
A small library that provides a pool for maintaining pre-started 'interactive' processes. A pool can be created by constructing a [*PSPPool*](https://viktorc.github.io/PSPPool/net/viktorc/pspp/PSPPool) instance. The first parameter of its constructors is an implementation of the [*ProcessManager*](https://viktorc.github.io/PSPPool/net/viktorc/pspp/ProcessManager) interface. This implementation is responsible for handling the start up and possibly the termination of the processes kept in the pool. Other parameters of the *PSPPool* constructors include the minimum and maximum size of the pool, a so called 'reserve size', and the time interval after which idle processes in the pool should be terminated. The size of the pool is always kept between the minimum pool size and the maximum pool size (both inclusive). The reserve size specifies the minimum number of threads that should always be available. Once the process pool is initialized, it accepts commands in the form of implementations of the [*Submission*](https://viktorc.github.io/PSPPool/net/viktorc/pspp/Submission) interface. Such an implementation contains one or more [*Command*](https://viktorc.github.io/PSPPool/net/viktorc/pspp/Command) instances and a boolean value that determines whether the process should be terminated after the execution of the submission. The submission is assigned to any one of the available processes in the pool. While executing a submission, the process cannot accept further submissions. The *Command* implementations allow for communication with the process via its standard in and standard/error out. This implementation specifies the instruction to send to the process' standard in and handles the output generated by the process as a response to the instruction. Moreover, the *Command* instance also determines when the message may be considered processed and when the process is ready for the next instruction. The library also provides some basic implementations of the *ProcessManager*, *Submission*, and *Command* interfaces to allow for the concise definition of process pooling systems for typical situations. The complete Javadoc can be found [here](http://viktorc.github.io/PSPPool/).
## Sample code
#### Create the pool:
		PSPPool pool = new PSPPool(new AbstractProcessManager(new ProcessBuilder("test.exe")) {
			
			@Override
			public boolean startsUpInstantly() {
				// The process is not instantly ready for instructions.
				return false;
			}
			@Override
			public boolean isStartedUp(String output, boolean standard) {
				// Once it has output "hi", it is ready to read from its standard in.
				return standard && "hi".equals(output);
			}
			@Override
			public void onStartup(ProcessShell shell) {
				/* Execute the command "start" on every process of the pool before it is 
				 * added to the list of available processes. Consider "start" processed 
				 * once the string "ok" has been output to the process' standard out. */
				try {
					shell.execute(new SimpleSubmission(new SimpleCommand("start",
							(c, o) -> "ok".equals(o), (c, o) -> true), false));
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			@Override
			public boolean terminate(ProcessShell shell) {
				try {
					/* Attempt to exit the process in an orderly way, if it fails let it be 
					 * terminated forcibly. */
					AtomicBoolean success = new AtomicBoolean(true);
					if (shell.execute(new SimpleSubmission(new SimpleCommand("stop",
							/* If the string "bye" is output to the standard out, the process
							 * is successfully terminated. */
							(c, o) -> "bye".equals(o),
							/* If a message is printed to the error out, let the process be 
							 * killed forcibly. */
							(c, o) -> {
								success.set(false);
								return true;
							}), false))) {
						// If success is false, the process will be terminated forcibly
						return success.get();
					}
				} catch (IOException e) {
					e.printStackTrace();
				}
				// If the something went wrong, the process is terminated forcibly.
				return false;
			}
			@Override
			public void onTermination(int resultCode) {
				// Don't do anything after a process has terminated.
			}
			
		}, 10, 50, 5, 60000, true);
In the example above, a *PSPPool* for a program called "test.exe" is created. Every time the pool starts a new process, it waits until the message "hi" is output to the process' standard out, signaling that it has started up, then the pool sends the instruction "start" to the process' standard in. The instruction "start" has the process 
sleep for 1 second before it outputs "ok". Once this message is output to the process' standard out, the pool considers the process started up and ready for submissions. Whenever the process needs to be terminated (either due to timing out or having it cancelled after the execution of a submission), the pool tries to close the process in an orderly way by sending it the "stop" instruction. If the response to this is "bye", the process is considered terminated. However, if something is printed to process' error out in response to "bye", the process is killed forcibly. The pool's minimum size is 10, its maximum size is 50, its reserve size is 5, its idle processes are terminated after 1 minute, and its verbose (meaning that logs all events related to the management of the pool to the console).
#### Submit commands:
		List<Future<?>> futures = new ArrayList<>();
		// Have 30 "process 5" commands be submitted to the pool in 3 seconds.
		for (int i = 0; i < 30; i++) {
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			futures.add(pool.submit(new SimpleSubmission(new SimpleCommand("process 5",
					(s, o) -> {
						/* If the response is "ready", print out everything written to the process'
						 * standard out. */
						if ("ready".equals(o)) {
							System.out.println(s.getJointStandardOutLines());
							return true;
						}
						return false;
					},
					/* If the response is sent to the process' error out, print out everything written 
					 * to its error out. */
					(s, o) -> {
						System.out.println(s.getJointErrorOutLines());
						return true;
					}), true)));
		}
Once the pool is initialized, it is sent 30 instructions within 3 seconds. The instruction "process 5" has the process sleep for 5 seconds, printing "in progress" to is standard out every second except for the 5th second, when it prints "ready". The *Submission* above also has the process that executed it cancelled afterwards as denoted by the second, boolean parameter of the constructor of [*SimpleSubmission*](https://viktorc.github.io/PSPPool/net/viktorc/pspp/SimpleSubmission). As the pool receives the submissions, it manages its size according to its minimum, maximum, and reserve size parameters.