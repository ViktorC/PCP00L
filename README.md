# PP4J [![Build Status](https://travis-ci.org/ViktorC/PP4J.svg?branch=master)](https://travis-ci.org/ViktorC/PP4J) [![Coverage Status](https://coveralls.io/repos/github/ViktorC/PP4J/badge.svg?branch=master)](https://coveralls.io/github/ViktorC/PP4J?branch=master) [![Quality Gate](https://sonarqube.com/api/badges/measure?key=net.viktorc:pp4j&metric=lines)](https://sonarqube.com/dashboard/index/net.viktorc:pp4j)
__PP4J__ (Process Pool for Java) is a library that provides a pool for maintaining a pool of processes. The pool communicates with the processes via their standard streams. A [*ProcessPool*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/ProcessPool) can be created by constructing a [*StandardProcessPool*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/impl/StandardProcessPool) instance directly or using one of the methods of the [*ProcessPools*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/ProcessPools) class. The first parameter of both the constructors and the convenience methods is an implementation of the [*ProcessManagerFactory*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/ProcessManagerFactory) functional interface for creating new instances of an implementation of the [*ProcessManager*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/ProcessManager) interface. These instances are responsible for specifying the processes and handling their start-up and possibly termination. Other parameters of the *StandardProcessPool* constructor include the minimum and maximum size of the pool, its reserve size. The size of the pool is always kept between the minimum pool size and the maximum pool size (both inclusive). The reserve size specifies the minimum number of processes that should always be available. Once the process pool is initialized, it accepts commands in the form of implementations of the [*Submission*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/Submission) interface. Such an implementation contains one or more [*Command*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/Command) implementations and a boolean value that determines whether the process should be terminated after the execution of the submission. The submission is assigned to any one of the available processes in the pool. While executing a submission, the process cannot accept further submissions. The *Command* implementation allows for communication with a process via its standard in and standard out/error. This implementation specifies the instruction to send to the process' standard in and handles the output generated by the process as a response to the instruction. Moreover, the *Command* implementation also determines when the instruction may be considered processed and when the process is ready for the next instruction. The library also provides some basic implementations of the *ProcessManager*, *Submission*, and *Command* interfaces to allow for the concise definition of process pooling systems for typical situations. The complete Javadoc can be found [here](http://viktorc.github.io/PP4J/).

	ProcessPool pool = new StandardProcessPool(() ->
			new AbstractProcessManager(new ProcessBuilder("test.exe"), 60000) {
		
		@Override
		public boolean startsUpInstantly() {
			return false;
		}
		@Override
		public boolean isStartedUp(String output, boolean standard) {
			// Once it has output "hi", it is ready to read from its standard in.
			return !standard || "hi".equals(output);
		}
		@Override
		public void onStartup(ProcessExecutor executor) {
			/* Execute the command "start" on every process of the pool before it is 
			 * added to the list of available processes. Consider "start" processed 
			 * once the string "ok" has been output to the process' standard out. */
			try {
				executor.execute(new SimpleSubmission(new SimpleCommand("start",
						(c, o) -> "ok".equals(o), (c, o) -> true), false));
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		@Override
		public boolean terminateGracefully(ProcessExecutor executor) {
			try {
				/* Attempt to exit the process in an orderly way, if it fails let it be 
				 * terminated forcibly. */
				AtomicBoolean success = new AtomicBoolean(true);
				if (executor.execute(new SimpleSubmission(new SimpleCommand("stop",
						/* If the string "bye" is output to the standard out, the process
						 * is successfully terminated. */
						(c, o) -> "bye".equals(o),
						/* If a message is printed to the error out, let the process be 
						 * killed forcibly. */
						(c, o) -> {
							success.set(false);
							return true;
						}), false))) {
					// If success is false, the process will be terminated forcibly
					return success.get();
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
			// If the something went wrong, the process is terminated forcibly.
			return false;
		}
	}, 10, 50, 5, true);

In the example above, a *StandardProcessPool* for a program called "test.exe" is created. Every time the pool starts a new process, it waits until the message "hi" is output to the process' standard out, signaling that it has started up, then the pool sends the instruction "start" to the process' standard in. The instruction "start" has the process sleep for 1 second before it outputs "ok". Once this message is output to the process' standard out, the pool considers the process ready for submissions. Whenever the process needs to be terminated (either due to timing out or having it cancelled after the execution of a submission), the pool tries to terminate the process in an orderly way by sending it the "stop" instruction. If the response to this is "bye", the process is considered terminated. However, if something is printed to the process' error out in response to the "stop" instruction, the process is killed forcibly. As specified in the constructor of [*AbstractProcessManager*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/impl/AbstractProcessManager), idle processes in the pool are terminated after 1 minute. The pool's minimum size is 10, its maximum size is 50, its reserve size is 5, and it is verbose (meaning that all events related to the management of the pool are logged using [SLF4J](https://www.slf4j.org/)).

	List<Future<?>> futures = new ArrayList<>();
	// Have 30 "process 5" commands be submitted to the pool in 3 seconds.
	for (int i = 0; i < 30; i++) {
		try {
			Thread.sleep(100);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		futures.add(pool.submit(new SimpleSubmission(new SimpleCommand("process 5",
				(s, o) -> {
					/* If the response is "ready", print out everything written to the 
					 * process' standard out in response to to the instruction. */
					if ("ready".equals(o)) {
						System.out.println(s.getJointStandardOutLines());
						return true;
					}
					return false;
				},
				/* If the response is sent to the process' error out, print out everything 
				 * written to its error out. */
				(s, o) -> {
					System.out.println(s.getJointStandardErrLines());
					return true;
				}), true)));
	}
	// Wait for the submission to be processed.
	for (Future<?> future : futures) {
		try {
			future.get();
		} catch (InterruptedException | ExecutionException e) {
			e.printStackTrace();
		}
	}
	// Shut down the pool.
	pool.shutdown();
	pool.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);

Once the pool is initialized, it is sent 30 instructions within 3 seconds. The instruction "process 5" has the process sleep for 5 seconds, printing "in progress" to its standard out every second except for the 5th second, when it prints "ready". The *Submission* above also has the process that executed it cancelled afterwards as denoted by the second, boolean parameter of the constructor of [*SimpleSubmission*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/impl/SimpleSubmission). As the pool receives the submissions, it manages its size according to its minimum, maximum, and reserve size parameters.

	ProcessPool pool = ProcessPools.newFixedProcessPool(() -> new SimpleProcessManager(
			new ProcessBuilder("bash")), 10);
	for (int i = 0; i < 10; i++) {
		pool.submit(new SimpleSubmission(new SimpleCommand("sleep 5; echo $USER",
				(c, o) -> {
					System.out.println(o);
					return true;
				}, (c, o) -> true)));
	}
	pool.shutdown();
	pool.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);

As demonstrated by the above code snippet, the *ProcessPools*, [*SimpleProcessManager*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/SimpleProcessManager), *SimpleSubmission*, and [*SimpleCommand*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/SimpleCommand) convenience classes allow for the concise definition of process pools and tasks to benefit from multiprocessing.

## Java Process Pool
PP4J also includes a pure Java process pool implementation built on top of the *StandardProcessPool*. The [*StandardJavaProcessPool*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/impl/StandardJavaProcessPool) implements both the *ProcessPool* and [*ExecutorService*](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html) interfaces through the [*JavaProcessPool*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/JavaProcessPool) interface. This allows it to be used similarly to the standard Java thread pools. It relies on a simple class that is executed using the *java* program to instantiate processes. These JVM processes are sent tasks using serialization and Base64 encoding. The results and exceptions are sent to the process pool the same way. The below snippet presents a sample usage of this process pool.

	JavaProcessPool pool = new StandardJavaProcessPool(new SimpleJavaProcessOptions(
			JVMArch.BIT_64, JVMType.CLIENT, 2, 8, 256, 60000), 10, 20, 2, false);
	Random rand = new Random();
	List<Future<Long>> results = new ArrayList<>();
	for (int i = 0; i < 10; i++) {
		results.add(pool.submit((Callable<Long> & Serializable) () -> {
			Thread.sleep(1000);
			return rand.nextLong();
		}));
	}
	for (Future<Long> res : results)
		System.out.println(res.get());
	pool.shutdown();
	pool.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);

The first argument of the constructor is an instance of an implementation of the [*JavaProcessOptions*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/JavaProcessOptions) interface which allows for the definition of options to use for the JVM instances and for the specification of the timeout of idle processes. The other paramters are used to define the size of the pool, similarly to the parameters of the constructor of *StandardProcessPool*. The [*Runnable*](https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html) and [*Callable*](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html) instances submitted to the pool must implement [*Serializable*](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html). Lambda expressions may be defined as serializable by casting them to an intersection of types as shown in the above code. The example also demonstrates the primary difference between multithreading and multiprocessing, i.e. processes have their own address spaces as opposed to threads. All the invocations of the `nextLong` method of `rand` return the same value as each process has its own copy of the instance.
