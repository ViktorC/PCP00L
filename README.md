# PP4J [![Build Status](https://travis-ci.org/ViktorC/PP4J.svg?branch=master)](https://travis-ci.org/ViktorC/PP4J) [![Quality Gate](https://sonarqube.com/api/badges/gate?key=net.viktorc:pp4j)](https://sonarqube.com/dashboard/index/net.viktorc:pp4j) [![Coverage Status](https://coveralls.io/repos/github/ViktorC/PP4J/badge.svg?branch=master)](https://coveralls.io/github/ViktorC/PP4J?branch=master) [![Maven Central](https://maven-badges.herokuapp.com/maven-central/net.viktorc/pp4j/badge.svg?style=plastic)](https://maven-badges.herokuapp.com/maven-central/net.viktorc/pp4j) [![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](https://www.apache.org/licenses/LICENSE-2.0.txt)
__PP4J__ (Process Pool for Java) is a multiprocessing library for Java that provides an API and standard implementations for process pools and process executors.

The process pools communicate with the processes via their standard streams. All process pools implement the [*ProcessExecutorService*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/ProcessExecutorService) interface. An implementation instance can be created by constructing a [*ProcessPoolExecutor*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/impl/ProcessPoolExecutor) instance directly or using one of the methods of the [*ProcessExecutors*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/impl/ProcessExecutors) class. The first parameter of both the constructors and the convenience methods is an implementation of the [*ProcessManagerFactory*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/ProcessManagerFactory) functional interface for creating new instances of an implementation of the [*ProcessManager*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/ProcessManager) interface. These instances are responsible for specifying the processes and handling their start-up and possibly termination. Other parameters of the *StandardProcessExecutorService* constructor include the minimum and maximum size of the pool, its reserve size. The size of the pool is always kept between the minimum pool size and the maximum pool size (both inclusive). The reserve size specifies the minimum number of processes that should always be available. Once the process pool is initialized, it accepts commands in the form of implementations of the [*Submission*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/Submission) interface which contain one or more [*Command*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/Command) implementations. The submission is assigned to any one of the available processes in the pool. While executing a submission, the process cannot accept further submissions. The *Command* implementation allows for communication with a process via its standard in and standard out/error. This implementation specifies the instruction to send to the process' standard in and handles the output generated by the process as a response to the instruction. Moreover, the *Command* implementation also determines when the instruction may be considered processed and when the process is ready for the next instruction. The library also provides some basic implementations of the *ProcessManager*, *Submission*, and *Command* interfaces to allow for the concise definition of process pooling systems for typical situations. The complete Javadoc can be found [here](http://viktorc.github.io/PP4J/).

	ProcessExecutorService pool = new ProcessPoolExecutor(() ->
			new AbstractProcessManager(new ProcessBuilder("test.exe"), 60000) {
			
					@Override
					public boolean startsUpInstantly() {
						return false;
					}
					@Override
					public boolean isStartedUp(String output, boolean standard) {
						return !standard || "hi".equals(output);
					}
					@Override
					public void onStartup(ProcessExecutor executor) {
						executor.execute(new SimpleSubmission(new SimpleCommand(
								"start", (c, o) -> "ok".equals(o), (c, o) -> true)));
					}
					@Override
					public boolean terminateGracefully(ProcessExecutor executor) {
						AtomicBoolean success = new AtomicBoolean(true);
						executor.execute(new SimpleSubmission(new SimpleCommand(
								"stop", (c, o) -> "bye".equals(o),
								(c, o) -> {
									success.set(false);
									return true;
								})));
						return success.get();
					}
				}, 10, 50, 5, true);

In the example above, a *ProcessPoolExecutor* for a program called "test.exe" is created. Every time the pool starts a new process, it waits until the message "hi" is output to the process' standard out, signaling that it has started up, then the pool sends the instruction "start" to the process' standard in. The instruction "start" has the process sleep for 1 second before it outputs "ok". Once this message is output to the process' standard out, the pool considers the process ready for submissions. Whenever the process needs to be terminated (either due to timing out or having it cancelled after the execution of a submission), the pool tries to terminate the process in an orderly way by sending it the "stop" instruction. If the response to this is "bye", the process is considered terminated. However, if something is printed to the process' error out in response to the "stop" instruction, the process is killed forcibly. As specified in the constructor of [*AbstractProcessManager*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/impl/AbstractProcessManager), idle processes in the pool are terminated after 1 minute. The pool's minimum size is 10, its maximum size is 50, its reserve size is 5, and it is verbose (meaning that all events related to the management of the pool are logged using [SLF4J](https://www.slf4j.org/)).

	Submission<?> submission = new SimpleSubmission(
				new AbstractCommand("process 5") {
					
					@Override
					public boolean generatesOutput() {
						return true;
					}
					@Override
					protected boolean onOutput(String outputLine, boolean standard) {
						if (standard) {
							if ("ready".equals(outputLine)) {
								System.out.println(getJointStandardOutLines());
								return true;
							}
							return false;
						} else {
							System.out.println(getJointStandardErrLines());
							return true;
						}
					}
				});
		List<Future<?>> futures = new ArrayList<>();
		for (int i = 0; i < 30; i++) {
			Thread.sleep(100);
			futures.add(pool.submit(submission, true));
		}
		pool.shutdown();
		pool.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);

Once the pool is initialized, it is sent 30 instructions within 3 seconds. The instruction "process 5" has the process sleep for 5 seconds, printing "in progress" to its standard out every second except for the 5th second, when it prints "ready". The *Submission* above also results in the termination of the executing process as denoted by the second, boolean parameter of the *submit* method of the pool. As the pool receives the submissions, it manages its size according to its minimum, maximum, and reserve size parameters.

	ProcessExecutorService pool = ProcessExecutors.newFixedProcessPool(
			() -> new SimpleProcessManager(new ProcessBuilder("bash")), 10);
	for (int i = 0; i < 10; i++) {
		pool.submit(new SimpleSubmission(new SimpleCommand("sleep 5; echo $USER",
				(c, o) -> {
					System.out.println(o);
					return true;
				}, (c, o) -> true)));
	}
	pool.shutdown();
	pool.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);

As demonstrated by the above code snippet, the *ProcessPools*, [*SimpleProcessManager*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/SimpleProcessManager), [*SimpleSubmission*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/impl/SimpleSubmission), and [*SimpleCommand*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/SimpleCommand) convenience classes allow for the concise definition of process pools and tasks to benefit from multiprocessing.

Besides the process pool, __PP4J__ also provides a standard implementation of the [*ProcessExecutor*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/ProcessExecutor) interface, [*SimpleProcessExecutor*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/impl/SimpleProcessExecutor) for the running of single processes without pooling. This, as presented below, allows for the synchronous execution of submissions in a single separate process with ease. In fact, *ProcessPoolExecutor* is based on the concept of pooling instances of a similar implementation of the *ProcessExecutor* interface.

	try (SimpleProcessExecutor executor = new SimpleProcessExecutor(
			new SimpleProcessManager(new ProcessBuilder("cmd.exe")))) {
		SimpleCommand command = new SimpleCommand("netstat & echo netstat done",
				(c, o) -> "netstat done".equals(o), (c, o) -> false);
		executor.start();
		executor.execute(new SimpleSubmission(command));
		System.out.println(command.getJointStandardOutLines());
	}

## Java Process Pool
Moreover, __PP4J__ includes a pure Java process pool implementation built on top of the *JavaProcessPoolExecutor*. The [*JavaProcessPoolExecutor*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/impl/JavaProcessPoolExecutor) implements both the *ProcessExecutorService* and [*ExecutorService*](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html) interfaces through the [*JavaProcessExecutorService*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/JavaProcessExecutorService) interface. This allows it to be used similarly to the standard Java thread pools. It relies on a simple class that is executed using the *java* program to instantiate processes. These JVM processes are sent tasks using serialization and Base64 encoding. The results and exceptions are sent to the process pool the same way. The below snippet presents a sample usage of this process pool.

	JavaProcessExecutorService pool = new JavaProcessPoolExecutor(
			new SimpleJavaProcessOptions(JVMArch.BIT_64, JVMType.CLIENT, 2, 8,
			256, 60000), 10, 20, 2, null, false);
	Random rand = new Random();
	List<Future<Long>> results = new ArrayList<>();
	for (int i = 0; i < 10; i++) {
		results.add(pool.submit((Callable<Long> & Serializable) () -> {
			Thread.sleep(1000);
			return rand.nextLong();
		}));
	}
	for (Future<Long> res : results)
		System.out.println(res.get());
	pool.shutdown();
	pool.awaitTermination(Long.MAX_VALUE, TimeUnit.DAYS);

The first argument of the constructor is an instance of an implementation of the [*JavaProcessOptions*](https://viktorc.github.io/PP4J/net/viktorc/pp4j/api/JavaProcessOptions) interface which allows for the definition of options to use for the JVM instances and for the specification of the timeout of idle processes. The other paramters are used to define the size of the pool, similarly to the parameters of the constructor of *ProcessPoolExecutor*. The [*Runnable*](https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html) and [*Callable*](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html) instances submitted to the pool must implement [*Serializable*](https://docs.oracle.com/javase/8/docs/api/java/io/Serializable.html). Lambda expressions may be defined as serializable by casting them to an intersection of types as shown in the above code. The example also demonstrates the primary difference between multithreading and multiprocessing, i.e. processes have their own address spaces as opposed to threads. All the invocations of the `nextLong` method of `rand` return the same value as each process has its own copy of the instance.
